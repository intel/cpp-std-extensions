
== `type_traits.hpp`

https://github.com/intel/cpp-std-extensions/blob/main/include/stdx/type_traits.hpp[`type_traits.hpp`]
contains a few things from the standard:

* https://en.cppreference.com/w/cpp/types/conditional[`conditional_t`]
  (implemented with fewer template instantiations than a typical standard
  implementation)
* https://en.cppreference.com/w/cpp/types/is_constant_evaluated[`is_constant_evaluated`] (from C++20)
* https://en.cppreference.com/w/cpp/types/is_function[`is_function_v`] (implemented with Walter Brown's method)
* https://en.cppreference.com/w/cpp/types/is_scoped_enum[`is_scoped_enum_v`] (from C++23)
* https://en.cppreference.com/w/cpp/types/remove_cvref[`remove_cvref_t`] (from C++20)
* https://en.cppreference.com/w/cpp/utility/to_underlying[`to_underlying`] (from C++23)
* https://en.cppreference.com/w/cpp/types/type_identity[`type_identity`] (from C++20)

=== `always_false_v`

`always_false_v` is a variable template that can be instantiated
with any number of type arguments and always evaluates to false at compile-time.
This is useful for writing `static_assert` where it must depend on types (at
least before C++23 and https://wg21.link/p2593[P2593]).

[source,cpp]
----
template <typename T>
auto f(T) {
  if constexpr (std::integral<T>) {
  } else {
    // doesn't work before C++23
    // static_assert(false, "S must be instantiated with an integral type");

    // instead, this works
    static_assert(stdx::always_false_v<T>, "S must be instantiated with an integral type");
  }
};
----

=== `is_function_object_v`

`is_function_object_v` is a variable template that detects whether a type is a
function object, like a lambda. It is true for generic lambdas, too.

[source,cpp]
----
auto f() {};
auto const lam = []{};
auto const gen_lam = []<typename>(){};

stdx::is_function_object_v<decltype(f)>;         // false
stdx::is_function_object_v<decltype(lam)>;       // true
stdx::is_function_object_v<decltype(gen_lam)>;   // true
----

=== `is_specialization_of_v`

`is_specialization_of_v` is a variable template that detects whether a type is a
specialization of a given template.

[source,cpp]
----
using O = std::optional<int>;

stdx::is_specialization_of_v<O, std::optional>;   // true
stdx::is_specialization_of_v<int, std::optional>; // false
----

`is_specialization_of_v` is suitable for templates with type parameters only
(not template-template parameters or NTTPs). For templates with value parameters,
use `is_value_specialization_of_v`.

[source,cpp]
----
template <auto N> struct S;
using T = S<0>;

stdx::is_value_specialization_of_v<T, S>; // true
----

NOTE: `is_type_specialization_of_v` is a synonym for `is_specialization_of_v`.

`is_specialization_of` is a function that can be used either way.

[source,cpp]
----
using O = std::optional<int>;
template <auto N> struct S;
using T = S<0>;

stdx::is_specialization_of<O, std::optional>(); // true
stdx::is_specialization_of<T, S>();             // true
----

NOTE: Perhaps until C++ has universal template parameters, there is no easy way
to write this function where the template takes a mixture of type, value, and
template parameters. So this is useful for templates whose parameters are all
types or all values.

=== `type_or_t`

`type_or_t` is an alias template that selects a type based on whether or not it
passes a predicate. If not, a default is returned.

[source,cpp]
----
using A = int *;
using T = stdx::type_or_t<std::is_pointer, A>;        // A

using B = int;
using X = stdx::type_or_t<std::is_pointer, B>;        // void (implicit default)
using Y = stdx::type_or_t<std::is_pointer, B, float>; // float (explicit default)
----

=== `type_list` and `value_list`

`type_list` is an empty `struct` templated over any number of types.
`value_list` is an empty `struct` templated over any number of NTTPs.

=== `template_for_each`

A `type_list` or a `value_list` can be iterated with `template_for_each`. A
function object whose call operator is a unary function template with no runtime
arguments is passed to each of these functions.

[source,cpp]
----
using L1 = stdx::type_list<std::integral_constant<int, 1>,
                           std::integral_constant<int, 2>>;
int x{};
stdx::template_for_each<L1>([&] <typename T> () { x += T::value; });
// x is now 3

using L2 = stdx::value_list<1, 2>;
int y{};
stdx::template_for_each<L2>([&] <auto V> () { y += V; });
// y is now 3
----

NOTE: A primary use case of `template_for_each` is to be able to use a list of
tag types without those types having to be complete.
